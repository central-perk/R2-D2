// Generated by CoffeeScript 1.7.1
var crypto, fs, getUTC, moment, path, validateLength, validateMaxLength, validateMaxMinLength, validateMinLength, _;

path = require('path');

fs = require('fs-extra');

_ = require('lodash');

moment = require('moment');

crypto = require('crypto');

getUTC = function(date) {
  return moment(date).utc().zone(-8);
};

validateLength = function(fieldValue) {
  return function(val) {
    return val.length === fieldValue.length;
  };
};

validateMaxMinLength = function(fieldValue) {
  var maxLength, minLength;
  minLength = fieldValue.minLength;
  maxLength = fieldValue.maxLength;
  return function(val) {
    var _ref;
    return (minLength < (_ref = val.length) && _ref < maxLength);
  };
};

validateMinLength = function(fieldValue) {
  var minLength;
  minLength = fieldValue.minLength;
  return function(val) {
    return minLength < val.length;
  };
};

validateMaxLength = function(fieldValue) {
  var maxLength;
  maxLength = fieldValue.maxLength;
  return function(val) {
    return val.length < maxLength;
  };
};

module.exports = {
  setG: function(rootPath) {
    var app, config, libs, pub, self;
    self = this;
    app = path.join(rootPath, 'app');
    config = path.join(rootPath, 'config');
    libs = path.join(rootPath, 'libs');
    pub = path.join(rootPath, 'pub');
    process.g = {
      config: require(config),
      utils: self,
      path: {
        root: rootPath,
        app: app,
        config: config,
        libs: libs,
        pub: pub
      }
    };
    _.each(fs.readdirSync(app), function(dir, index) {
      var dirPath;
      dirPath = path.join(app, dir);
      return process.g.path[dir] = dirPath;
    });
    _.each(fs.readdirSync(libs), function(file, index) {
      var fileName;
      if (~file.indexOf('.js')) {
        fileName = file.replace('.js', '');
        return process.g.path[fileName] = path.join(libs, file);
      }
    });
    return require(process.g.path.controllers);
  },
  getSchemaConfig: function(schemaName) {
    var FIELD_TYPE_MAP, config, modelsPath, schemaConfig, schemaConfigFilePath, schemaFileName;
    config = process.g.config;
    FIELD_TYPE_MAP = config.FIELD_TYPE_MAP;
    schemaFileName = schemaName + '.json';
    modelsPath = process.g.path.models;
    schemaConfigFilePath = path.join(modelsPath, 'config', schemaFileName);
    schemaConfig = JSON.parse(fs.readFileSync(schemaConfigFilePath, 'utf8'));
    _.forEach(schemaConfig, function(fieldValue, fieldKey) {
      var validate;
      fieldValue.type = FIELD_TYPE_MAP[fieldValue.type];
      if (fieldValue.required) {
        fieldValue.required = "" + fieldValue.label + "不能为空";
      }
      validate = [];
      if (fieldValue.length) {
        validate.push({
          validator: validateLength(fieldValue),
          msg: "" + fieldValue.label + "长度必须为" + fieldValue.length
        });
      }
      if (fieldValue.minLength && fieldValue.maxLength) {
        validate.push({
          validator: validateMaxMinLength(fieldValue),
          msg: "" + fieldValue.label + "长度必须为" + fieldValue.minLength + "-" + fieldValue.maxLength
        });
      } else if (fieldValue.minLength) {
        validate.push({
          validator: validateMinLength(fieldValue),
          msg: "" + fieldValue.label + "长度必须大于" + fieldValue.minLength
        });
      } else if (fieldValue.maxLength) {
        validate.push({
          validator: validateMaxLength(fieldValue),
          msg: "" + fieldValue.label + "长度必须小于" + fieldValue.minLength
        });
      }
      if (validate.length) {
        fieldValue.validate = validate;
      }
      delete fieldValue.label;
      delete fieldValue.minLength;
      return delete fieldValue.maxLength;
    });
    return schemaConfig;
  },
  dateTimeFormat: function(date) {
    return getUTC(date).format("YYYY-MM-DD HH:mm");
  },
  tsFormat: function(date) {
    return getUTC(date).format("YYYYMMDDHHmmss");
  },
  md5: function(text) {
    return crypto.createHash('md5').update(text).digest('hex');
  },
  createToken: function(text) {
    var randomNumber;
    randomNumber = Math.random();
    text = text + String(randomNumber);
    return this.md5(text);
  },
  createID: function(length) {
    var chars, i, str, _i;
    length = length || 8;
    chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz'.split('');
    str = '';
    for (i = _i = 1; 1 <= length ? _i <= length : _i >= length; i = 1 <= length ? ++_i : --_i) {
      str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
  },
  getCtrl: function(ctrlName) {
    return require(path.join(process.g.path.controllers, 'mapping', ctrlName));
  },
  getDao: function(daoName) {
    return require(process.g.path.daos)[daoName];
  },
  walk: function(rootPath, include, exclude, removePath) {
    var directories, output;
    output = [];
    directories = [];
    include = include || /(.*)\.js$/;
    _.each(fs.readdirSync(rootPath), function(file, index) {
      var newRootPath, stat;
      newRootPath = path.join(rootPath, file);
      stat = fs.statSync(newRootPath);
      if (stat.isFile()) {
        if (include.test(file) && (!exclude || !exclude.test(file))) {
          return output.push(newRootPath.replace(removePath, ''));
        }
      } else if (stat.isDirectory()) {
        if (!exclude || !exclude.test(file)) {
          return directories.push(newRootPath);
        }
      }
    });
    _.each(directories, function(dir, index) {
      return output = output.concat(walk(dir, include, exclude, removePath));
    });
    return output;
  }
};

//# sourceMappingURL=utils.map
