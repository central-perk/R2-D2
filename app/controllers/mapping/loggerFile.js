// Generated by CoffeeScript 1.7.1
var LOGGERFILE_MAXSIZE, LOGGERFILE_STATUS, async, checkLogSize, config, createLoggerFile, filePath, fs, getWriteableLoggerFilePath, loggerFileDao, loggersPath, path, utils, writeFile;

path = require('path');

fs = require('fs-extra');

async = require('async');

config = process.g.config;

utils = process.g.utils;

filePath = process.g.path;

LOGGERFILE_STATUS = config.LOGGERFILE.status;

LOGGERFILE_MAXSIZE = config.LOGGERFILE.maxSize;

loggersPath = path.join(filePath.root, 'loggers');

loggerFileDao = utils.getDao('loggerFile');

getWriteableLoggerFilePath = function(loggerName, callback) {
  var appID, logName;
  appID = loggerName.split('.')[0];
  logName = loggerName.split('.')[1];
  return async.waterfall([
    function(cb) {
      return loggerFileDao.getOne({
        app: appID,
        name: loggerName,
        status: LOGGERFILE_STATUS.writeable
      }, cb);
    }
  ], function(err, loggerFile) {
    var loggerFileName, loggerFilePath, loggerFileSizeOK;
    if (loggerFile) {
      loggerFileName = loggerFile._fileName;
      loggerFilePath = path.join(loggersPath, loggerFileName);
      loggerFileSizeOK = checkLogSize(loggerFilePath);
      if (loggerFileSizeOK) {
        return callback(null, loggerFilePath);
      } else {
        return loggerFileDao.update({
          _fileName: loggerFileName
        }, {
          status: LOGGERFILE_STATUS.unstorage
        }, function(err, affected) {
          loggerFile.status = LOGGERFILE_STATUS.unstorage;
          process.emit('enqueueStorage', loggerFile);
          return createLoggerFile(loggerName, callback);
        });
      }
    } else {
      return createLoggerFile(loggerName, callback);
    }
  });
};

checkLogSize = function(loggerFilePath) {
  var e, size;
  try {
    size = fs.readFileSync(loggerFilePath, 'utf8').length;
    return LOGGERFILE_MAXSIZE > size;
  } catch (_error) {
    e = _error;
    console.log(e);
    return false;
  }
};

createLoggerFile = function(loggerName, callback) {
  var appID, logName, loggerFileName, loggerFilePath;
  appID = loggerName.split('.')[0];
  logName = loggerName.split('.')[1];
  loggerFileName = "" + loggerName + "." + (utils.tsFormat()) + ".log";
  loggerFilePath = path.join(loggersPath, loggerFileName);
  if (fs.existsSync(loggerFilePath)) {
    return callback(null, loggerFilePath);
  } else {
    fs.createFileSync(loggerFilePath);
    return loggerFileDao.create({
      app: appID,
      name: loggerName,
      _fileName: loggerFileName
    }, function(err, raw) {
      return callback(err, loggerFilePath);
    });
  }
};

writeFile = function(loggerFilePath) {
  return function(message, cb) {
    var loggerFileName;
    loggerFileName = path.basename(loggerFilePath);
    message._fileName = loggerFileName;
    message = JSON.stringify(message, null, 0) + '\n';
    if (!fs.existsSync(loggerFilePath)) {
      fs.createFileSync(loggerFilePath);
    }
    return fs.writeFile(loggerFilePath, message, {
      encoding: 'utf8',
      flag: 'a'
    }, cb);
  };
};

module.exports = {
  write: function(loggerName, callback) {
    return getWriteableLoggerFilePath(loggerName, function(err, loggerFilePath) {
      return callback(err, writeFile(loggerFilePath));
    });
  },
  readyStorage: function(callback) {
    return logFileDao.Model.update({
      status: LOGFILE_STATUS.writeable
    }, {
      status: LOGFILE_STATUS.unstorage
    }, {
      multi: true
    }, callback);
  },
  updateStatus: function(loggerFile, callback) {
    var loggerFileName, loggerFileStatus;
    loggerFileName = loggerFile._fileName;
    loggerFileStatus = loggerFile.status;
    return loggerFileDao.update({
      _fileName: loggerFileName
    }, {
      status: loggerFileStatus
    }, callback);
  }
};

//# sourceMappingURL=loggerFile.map
