// Generated by CoffeeScript 1.7.1
var Dao, LOGFILE_STATUS, async, config, fs, getFile, json2db, log2json, logFileDao, logsPath, maxLines, mongoose, path, updateLogFileStatus, utils, _;

fs = require('fs-extra');

path = require('path');

_ = require('lodash');

async = require('async');

mongoose = require('mongoose');

config = process.g.config;

LOGFILE_STATUS = config.STATUS.LOGFILE;

utils = process.g.utils;

maxLines = config.STORAGE.maxLines;

logsPath = process.g.logsPath;

logFileDao = require(process.g.daoPath)['logFile'];

Dao = {};

getFile = function(callback) {
  return logFileDao.get({
    status: {
      '$in': [20, 30]
    }
  }, callback);
};

log2json = function(data) {
  var logs;
  logs = data.split('\n').slice(0, -1);
  _.each(logs, function(log, index) {
    return logs[index] = JSON.parse(logs[index]);
  });
  return logs;
};

updateLogFileStatus = function(sLogFileName, status, cb) {
  return logFileDao.update({
    fileName: sLogFileName
  }, {
    status: status
  }, cb);
};

json2db = function(Model, logs, callback) {
  var nLen;
  nLen = logs.length;
  return Model.create(logs.slice(0, maxLines), function(err, raw) {
    if (!err) {
      if (maxLines >= nLen) {
        console.log(logs[0], '-----');
        return updateLogFileStatus(logs[0]._fileName, LOGFILE_STATUS.storaged, callback);
      } else {
        return json2db(Model, logs.slice(maxLines), callback);
      }
    } else {
      return callback(err);
    }
  });
};

module.exports = {
  start: function() {
    var kue;
    kue = utils.getCtrl('kue');
    return getFile(function(err, aLogFile) {
      return _.each(aLogFile, function(oLogFile) {
        return kue.enqueueStorage(oLogFile);
      });
    });
  },
  store: function(oLogFile, callback) {
    var Model, nLogFileStatus, sAppID, sFullLogName, sLogFilePath, sLogName;
    sAppID = oLogFile.appID;
    sLogName = oLogFile.name;
    sFullLogName = "" + sAppID + "." + sLogName;
    sLogFilePath = path.join(logsPath, oLogFile.fileName);
    nLogFileStatus = oLogFile.status;
    Model = mongoose.model(sFullLogName);
    return async.waterfall([
      function(cb) {
        if (nLogFileStatus === LOGFILE_STATUS.unstorage) {
          return cb(null, 0);
        } else {
          return Model.count({
            fileName: oLogFile.fileName
          }, cb);
        }
      }, function(nLine, cb) {
        return fs.readFile(sLogFilePath, 'utf-8', function(err, logs) {
          console.log(logs);
          if (!err) {
            logs = log2json(logs);
            logs = logs.slice(Number(nLine));
            return updateLogFileStatus(oLogFile.fileName, LOGFILE_STATUS.storaging, function(err) {
              if (!err) {
                return json2db(Model, logs, cb);
              } else {
                return cb(err);
              }
            });
          } else {
            return cb(err);
          }
        });
      }
    ], callback);
  }
};
