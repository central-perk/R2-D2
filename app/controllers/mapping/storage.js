// Generated by CoffeeScript 1.7.1
var Dao, LOGFILE_STATUS, async, config, fs, getFile, json2db, log2json, logFileDao, logsPath, maxLines, mongoose, path, updateLogFileStatus, utils, _;

fs = require('fs-extra');

path = require('path');

_ = require('lodash');

async = require('async');

mongoose = require('mongoose');

config = process.g.config;

LOGFILE_STATUS = config.STATUS.LOGFILE;

utils = process.g.utils;

maxLines = config.STORAGE.maxLines;

logsPath = process.g.logsPath;

logFileDao = require(process.g.daoPath)['logFile'];

Dao = {};

getFile = function(callback) {
  return logFileDao.get({
    status: {
      '$in': [20, 30]
    }
  }, function(err, oLogFiles) {
    var aLogFile;
    aLogFile = _.reduce(oLogFiles, function(arr, oLogFile) {
      var name, status;
      name = oLogFile.name;
      status = oLogFile.status;
      arr.push({
        name: name,
        status: status
      });
      return arr;
    }, []);
    return callback(null, aLogFile);
  });
};

log2json = function(data) {
  var logs;
  logs = data.split('\n').slice(0, -1);
  _.each(logs, function(log, index) {
    logs[index] = JSON.parse(logs[index]);
    delete logs[index].level;
    return delete logs[index].message;
  });
  return logs;
};

updateLogFileStatus = function(sfileName, status, cb) {
  return logFileDao.update({
    name: sfileName
  }, {
    status: status
  }, cb);
};

json2db = function(Model, logs, callback) {
  var nLen;
  nLen = logs.length;
  return Model.create(logs.slice(0, maxLines), function(err, raw) {
    if (!err) {
      if (maxLines >= nLen) {
        return updateLogFileStatus(logs[0].fileName, LOGFILE_STATUS.storaged, callback);
      } else {
        return json2db(Model, logs.slice(maxLines), callback);
      }
    } else {
      return callback(err);
    }
  });
};

module.exports = {
  start: function() {
    var kue;
    kue = utils.getCtrl('kue');
    return getFile(function(err, aLogFile) {
      return _.each(aLogFile, function(oLogFile) {
        return kue.enqueueStorage(oLogFile);
      });
    });
  },
  store: function(oLogFile, callback) {
    var Model, aLogFileTemp, appID, logFileStatus, sLogFilePath, sLogModelName, sLogType;
    aLogFileTemp = oLogFile.name.split('.');
    appID = aLogFileTemp[0];
    sLogType = aLogFileTemp[1];
    sLogModelName = "" + appID + "." + sLogType;
    sLogFilePath = path.join(logsPath, oLogFile.name);
    logFileStatus = oLogFile.status;
    Model = mongoose.model(sLogModelName);
    return async.waterfall([
      function(cb) {
        if (logFileStatus === LOGFILE_STATUS.unstorage) {
          return cb(null, 1);
        } else {
          return Model.count({
            fileName: oLogFile.name
          }, cb);
        }
      }, function(nLine, cb) {
        return fs.readFile(sLogFilePath, 'utf-8', function(err, logs) {
          if (!err) {
            logs = log2json(logs);
            logs = logs.slice(Number(nLine) - 1);
            return updateLogFileStatus(oLogFile.name, LOGFILE_STATUS.storaging, function(err) {
              if (!err) {
                return json2db(Model, logs, cb);
              } else {
                return cb(err);
              }
            });
          } else {
            return cb(err);
          }
        });
      }
    ], callback);
  }
};
